import os
import glob
import pandas as pd
import torch
from torch.utils.data import DataLoader, TensorDataset
import torch.nn as nn
import torch.optim as optim
from src.model.MalDetModel import MalDetModel


def train(
    train_dir: str,
    output: str,
    epochs: int = 10,
    batch_size: int = 64,
    learning_rate: float = 0.001,
):
    # Load the dataset
    train = pd.read_csv(train_dir)  # Replace with actual file path

    train = train.apply(lambda x: pd.to_numeric(x, errors="coerce")).dropna()

    # Split into features and target label
    X_train = train.iloc[:, :-1].values  # All columns except the last one
    y_train = train.iloc[:, -1].values  # Last column ('class')
    # Convert labels to binary (S = 0, B = 1)

    # Convert to PyTorch tensors
    X_train_tensor = torch.tensor(X_train, dtype=torch.float32)
    y_train_tensor = torch.tensor(y_train, dtype=torch.long)

    # Create data loaders
    train_dataset = TensorDataset(X_train_tensor, y_train_tensor)

    train_loader = DataLoader(train_dataset, batch_size=batch_size, shuffle=True)

    # Initialize the model, loss function, and optimizer
    input_size = X_train.shape[1]
    model = MalDetModel(input_size)

    base_models = glob.glob("model/base/*.pth")
    if len(base_models) > 0:
        model.load_state_dict(torch.load(base_models[0], weights_only=True))

    # Loss function and optimizer
    criterion = nn.CrossEntropyLoss()
    optimizer = optim.Adam(model.parameters(), lr=learning_rate)

    # Training loop
    for epoch in range(epochs):
        model.train()
        running_loss = 0.0
        for inputs, labels in train_loader:
            # Zero the gradients
            optimizer.zero_grad()

            # Forward pass
            outputs = model(inputs)
            loss = criterion(outputs, labels)

            # Backward pass and optimization
            loss.backward()
            optimizer.step()

            running_loss += loss.item()

        print(f"Epoch [{epoch+1}/{epochs}], Loss: {running_loss/len(train_loader):.4f}")

    torch.save(model.state_dict(), output)
